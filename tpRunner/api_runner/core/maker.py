#!/usr/bin/python
# -*- coding:utf-8 _*- 
"""
@author:TXU
@file:maker
@time:2022/04/03
@email:tao.xu2008@outlook.com
@description: python pytest格式用例创建（test_*.py）

jinja2[模板,常用于Python Web 前后端不分离]: https://jinja.palletsprojects.com/en/3.0.x/intro/
black[代码格式化]: https://black.readthedocs.io/en/stable/
from string import Template 也可实现字符串模板替换
string包下的Template: https://docs.python.org/3/library/string.html#format-string-syntax
argparse[命令行选项]：https://docs.python.org/zh-cn/3/library/argparse.html
"""
import os
import string
import subprocess
from typing import Text, List, Tuple, Dict, Set, NoReturn

import jinja2
from loguru import logger
# from yapf.yapflib.yapf_api import FormatCode
import py_compile

from utils import exceptions
from utils.util import is_support_multiprocessing
from api_runner import __version__
from api_runner.core.compat import (
    ensure_testcase_v3_api,
    ensure_testcase_v3,
    convert_variables,
    compat_path_sep,
)

from api_runner.core.builtin_loader import (
    # load_folder_files,
    # load_test_file,
    load_testcase,
    load_testsuite,
    load_project_meta,
    convert_relative_project_root_dir,
)
from api_runner.core.response import uniform_validator
from api_runner.core.utils import merge_variables

# pytest测试文件，缓存字典，保存该字典避免重复生成
pytest_files_made_cache_mapping: Dict[Text, List[Text]] = {}

# pytest测试文件导入 setup/teardown 模块，保存该字典避免重复生成，并提供数据获取
# [{cls:import_expr}]
pytest_model_import_cache_mapping: Dict = {}

# pytest运行集合，排除引入的测试用例
pytest_files_run_set: Set = set()

RUNNER = 'runner'  # runner || runner_plus

# test_xx.py 模板
__RUNNER_TEMPLATE__ = jinja2.Template(
    """#!/usr/bin/python
# -*- coding:utf-8 _*- 
# author:TXU
# email:tao.xu2008@outlook.com
# NOTE: Generated By api test runner v{{ version }}

import allure
import pytest
from api_runner.core.parser import parse_parameters as Parameters
from api_runner.core import ApiRunner, Config, Step, RunRequest, RunTestCase

{% if imports_list and diff_levels > 0 %}
import sys
from pathlib import Path
sys.path.insert(0, str(Path(__file__){% for _ in range(diff_levels) %}.parent{% endfor %}))
{% endif %}
{% for import_str in imports_list %}
{{ import_str }}
{% endfor %}

@allure.epic("{{ epic }}")
@allure.story("{{ story }}")
@allure.suite("{{ suite }}")
class TestCase{{ class_name }}(ApiRunner):
    '''{{ case_desc }}'''
    case_id = {{ case_id }}
    test_type = "{{ test_type }}"
    {% if parameters %}
    @pytest.mark.parametrize("param", Parameters({{parameters}}))
    def test_start(self, param):
        super().test_start(param)
    {% endif %}
    config = {{ config_chain_style }}
    teststeps = [
        {% for step_chain_style in teststeps_chain_style %}
        {{ step_chain_style }},
        {% endfor %}
    ]
    {% if setups %}
    def setup_class(self):
        '''setup class'''{% for setup in setups %}
        {{ setup }}().test_start()
        {% endfor %}
    {% endif %}
    {% if teardowns %}
    def teardown_class(self):
        '''teardown class'''{% for teardown in teardowns %}
        {{ teardown }}().test_start()
    {% endfor %}{% endif %}
    @allure.title("{{ case_name }}")
    @allure.description('''{{ case_desc }}''')
    @allure.testcase("{{ case_link }}", "禅道用例-{{ case_id }}" )
    @allure.tag(*{{ case_tags }})
    def test_start(self):
        super().test_start()


if __name__ == "__main__":
    TestCase{{ class_name }}().test_start()

"""
)

__RUNNER_PLUS_TEMPLATE__ = jinja2.Template(
    """#!/usr/bin/python
# -*- coding:utf-8 _*- 
# author:TXU
# email:tao.xu2008@outlook.com
# NOTE: Generated By api test runner v{{ version }}

import allure
import pytest
from apps.api_test.runner.core import Parameters
from apps.api_test.runner.core import ApiRunner, Config, Step, RunRequest, RunTestCase
from apps.api_test.runner.core.runner_plus import StepRequestRunner
from apps.api_test.runner.core.runner_meta_classs import RunnerMetaClass

{% if imports_list and diff_levels > 0 %}
import sys
from pathlib import Path
sys.path.insert(0, str(Path(__file__){% for _ in range(diff_levels) %}.parent{% endfor %}))
{% endif %}
{% for import_str in imports_list %}
{{ import_str }}
{% endfor %}

@allure.feature('{{ case_desc }}')
class TestCase{{ class_name }}(StepRequestRunner, metaclass=RunnerMetaClass):
    '''{{ case_desc }}'''
    {% if parameters %}
    @pytest.mark.parametrize("param", Parameters({{parameters}}))
    def test_start(self, param):
        super().test_start(param)
    {% endif %}
    config = {{ config_chain_style }}
    teststeps = [
        {% for step_chain_style in teststeps_chain_style %}
            {{ step_chain_style }},
        {% endfor %}
    ]


if __name__ == "__main__":
    TestCase{{ class_name }}().get_summary()
"""
)

__MODULE_CONFTEST_TEMPLATE__ = jinja2.Template(
    """import pytest
{% if imports_list and diff_levels > 0 %}
import sys
from pathlib import Path
sys.path.insert(0, str(Path(__file__){% for _ in range(diff_levels) %}.parent{% endfor %}))
{% endif %}
{% for import_str in imports_list %}
{{ import_str }}
{% endfor %}

@pytest.fixture(scope="session", autouse=True)
def setup_teardown_module():
    # setup
    {% for setup_class in setup_class_list %}
    {{ setup_class }}().test_start()
    {% endfor %}
    yield
    # teardown
    {% for teardown_class in teardown_class_list %}
    {{ teardown_class }}().test_start()
    {% endfor %}
"""
)

__TEMPLATE__ = __RUNNER_TEMPLATE__ if RUNNER == 'runner' else __RUNNER_PLUS_TEMPLATE__


def __ensure_absolute(path: Text) -> Text:
    if path.startswith("./"):
        # Linux/Darwin, hrun ./test.yml
        path = path[len("./"):]
    elif path.startswith(".\\"):
        # Windows, hrun .\\test.yml
        path = path[len(".\\"):]

    path = compat_path_sep(path)
    project_meta = load_project_meta(path)

    if os.path.isabs(path):
        absolute_path = path
    else:
        absolute_path = os.path.join(project_meta.RootDir, path)

    # ensure new directory exists
    absolute_dir = os.path.dirname(absolute_path)
    if not os.path.exists(absolute_dir):
        os.makedirs(absolute_dir)

    # ensure new file exists
    if not os.path.exists(absolute_path):
        with open(absolute_path, 'w') as f:
            f.write('')

    if not os.path.isfile(absolute_path):
        logger.error(f"Invalid testcase file path: {absolute_path}")
        # sys.exit(1)
        raise Exception(f"Invalid testcase file path: {absolute_path}")

    return absolute_path


def ensure_file_abs_path_valid(file_abs_path: Text) -> Text:
    """ ensure file path valid for pytest, handle cases when directory name includes dot/hyphen/space

    Args:
        file_abs_path: absolute file path

    Returns:
        ensured valid absolute file path

    """
    project_meta = load_project_meta(file_abs_path)
    raw_abs_file_name, file_suffix = os.path.splitext(file_abs_path)
    file_suffix = file_suffix.lower()

    raw_file_relative_name = convert_relative_project_root_dir(raw_abs_file_name)
    if raw_file_relative_name == "":
        return file_abs_path

    path_names = []
    for name in raw_file_relative_name.rstrip(os.sep).split(os.sep):

        if name[0] in string.digits:
            # ensure file name not startswith digit
            # 19 => T19, 2C => T2C
            name = f"T{name}"

        if name.startswith("."):
            # avoid ".csv" been converted to "_csv"
            pass
        else:
            # handle cases when directory name includes dot/hyphen/space
            name = name.replace(" ", "_").replace(".", "_")  # .replace("-", "_")

        path_names.append(name)

    new_file_path = os.path.join(
        project_meta.RootDir, f"{os.sep.join(path_names)}{file_suffix}"
    )
    return new_file_path


def __ensure_testcase_module(path: Text) -> NoReturn:
    """ ensure pytest files are in python module, generate __init__.py on demand
    """
    init_file = os.path.join(os.path.dirname(path), "__init__.py")
    if os.path.isfile(init_file):
        return

    with open(init_file, "w", encoding="utf-8") as f:
        f.write("# NOTICE: Generated By ApiRunner. DO NOT EDIT!\n")


def convert_testcase_path(testcase_abs_path: Text) -> Tuple[Text, Text]:
    """convert single YAML/JSON testcase path to python file"""
    testcase_new_path = ensure_file_abs_path_valid(testcase_abs_path)

    dir_path = os.path.dirname(testcase_new_path)
    file_name, _ = os.path.splitext(os.path.basename(testcase_new_path))
    testcase_python_abs_path = os.path.join(dir_path, f"{file_name}.py")

    # convert title case, e.g. request_with_variables => RequestWithVariables
    name_in_title_case = file_name.title().replace("_", "")

    return testcase_python_abs_path, name_in_title_case


def format_pytest_with_black(*python_paths: Text) -> NoReturn:
    logger.info("format pytest cases with black ...")
    try:
        if is_support_multiprocessing() or len(python_paths) <= 1:
            subprocess.run(["black", *python_paths])
        else:
            logger.warning("this system does not support multiprocessing well, format files one by one ...")
            [subprocess.run(["black", path]) for path in python_paths]
    except subprocess.CalledProcessError as ex:
        logger.error(ex)
        # sys.exit(1)
        raise Exception(ex)
    except FileNotFoundError:
        err_msg = """
missing dependency tool: black
install black manually and try again:
$ pip install black
"""
        logger.error(err_msg)
        # sys.exit(1)
        raise Exception(err_msg)
    except Exception as e:
        logger.error(e)
        raise Exception(e)


def compile_pytest(*python_paths: Text) -> NoReturn:
    logger.info("compile pytest cases ...")
    try:
        [py_compile.compile(path) for path in python_paths]
    except Exception as e:
        logger.error(e)
        raise e


def make_config_chain_style(config: Dict) -> Text:
    config_chain_style = f'Config()'

    if config["variables"]:
        variables = config["variables"]
        config_chain_style += f".variables(**{variables})"

    if "description" in config:
        config_chain_style += f'.description("{config["description"]}")'

    if "suite_name" in config:
        config_chain_style += f'.suite_name("{config["suite_name"]}")'

    if "case_id" in config:
        case_id = config["case_id"]
        config_chain_style += f".case_id({case_id})"

    if "case_name" in config:
        config_chain_style += f'.case_name("{config["case_name"]}")'

    if "base_url" in config:
        config_chain_style += f'.base_url("{config["base_url"]}")'

    if "verify" in config:
        config_chain_style += f'.verify({config["verify"]})'

    if "export" in config:
        config_chain_style += f'.export(*{config["export"]})'

    if "weight" in config:
        config_chain_style += f'.locust_weight({config["weight"]})'

    return config_chain_style


def make_request_chain_style(request: Dict) -> Text:
    method = request["method"].lower()
    url = request["url"]
    request_chain_style = f'.{method}("{url}")'

    if "params" in request:
        params = request["params"]
        request_chain_style += f".with_params(**{params})"

    if "headers" in request:
        headers = request["headers"]
        request_chain_style += f".with_headers(**{headers})"

    if "cookies" in request:
        cookies = request["cookies"]
        request_chain_style += f".with_cookies(**{cookies})"

    if "data" in request:
        data = request["data"]
        if isinstance(data, Text):
            data = f'"{data}"'
        request_chain_style += f".with_data({data})"

    if "json" in request:
        req_json = request["json"]
        if isinstance(req_json, Text):
            req_json = f'"{req_json}"'
        request_chain_style += f".with_json({req_json})"

    if "timeout" in request:
        timeout = request["timeout"]
        request_chain_style += f".set_timeout({timeout})"

    if "verify" in request:
        verify = request["verify"]
        request_chain_style += f".set_verify({verify})"

    if "allow_redirects" in request:
        allow_redirects = request["allow_redirects"]
        request_chain_style += f".set_allow_redirects({allow_redirects})"

    if "upload" in request:
        upload = request["upload"]
        request_chain_style += f".upload(**{upload})"

    return request_chain_style


def make_teststep_chain_style(teststep: Dict) -> Text:
    if teststep.get("request"):
        step_info = f'RunRequest("{teststep["step_name"]}")'
    elif teststep.get("testcase"):
        step_info = f'RunTestCase("{teststep["step_name"]}")'
    else:
        raise exceptions.TestCaseFormatError(f"Invalid teststep: {teststep}")

    if "id" in teststep:
        step_id = teststep["id"]
        step_info += f".with_id({step_id})"

    if "sid" in teststep:
        step_sid = teststep["sid"]
        step_info += f'.with_sid("{step_sid}")'

    if "is_skip" in teststep:
        is_skip = teststep["is_skip"]
        step_info += f".with_is_skip({is_skip})"

    if "is_api_valid" in teststep:
        is_api_valid = teststep["is_api_valid"]
        step_info += f".with_is_api_valid({is_api_valid})"

    if "is_api_updated" in teststep:
        is_api_updated = teststep["is_api_updated"]
        step_info += f".with_is_api_updated({is_api_updated})"

    if "skipif" in teststep:
        skipif = teststep["skipif"]
        step_info += f'.with_skipif("{skipif}")'

    if "depends" in teststep:
        depends = teststep["depends"]
        step_info += f".with_depends({depends})"

    base_url = teststep.get("base_url")
    if base_url:
        step_info += f'.with_base_url("{base_url}")'

    if "description" in teststep:
        description = teststep["description"]
        step_info += f'.with_description("{description}")'

    if "api_id" in teststep:
        api_id = teststep["api_id"]
        step_info += f".with_api_id({api_id})"

    if "api_description" in teststep:
        api_description = teststep["api_description"]
        step_info += f'.with_api_description("{api_description}")'

    if "variables" in teststep:
        variables = teststep["variables"]
        step_info += f".with_variables(**{variables})"

    if "setup_hooks" in teststep:
        setup_hooks = teststep["setup_hooks"]
        for hook in setup_hooks:
            if isinstance(hook, Text):
                step_info += f'.setup_hook("{hook}")'
            elif isinstance(hook, Dict) and len(hook) == 1:
                assign_var_name, hook_content = list(hook.items())[0]
                step_info += f'.setup_hook("{hook_content}", "{assign_var_name}")'
            else:
                raise exceptions.TestCaseFormatError(f"Invalid setup hook: {hook}")

    if teststep.get("request"):
        step_info += make_request_chain_style(teststep["request"])
    elif teststep.get("testcase"):
        testcase = teststep["testcase"]
        call_ref_testcase = f".call({testcase})"
        step_info += call_ref_testcase

    if "teardown_hooks" in teststep:
        teardown_hooks = teststep["teardown_hooks"]
        for hook in teardown_hooks:
            if isinstance(hook, Text):
                step_info += f'.teardown_hook("{hook}")'
            elif isinstance(hook, Dict) and len(hook) == 1:
                assign_var_name, hook_content = list(hook.items())[0]
                step_info += f'.teardown_hook("{hook_content}", "{assign_var_name}")'
            else:
                raise exceptions.TestCaseFormatError(f"Invalid teardown hook: {hook}")

    if "extract" in teststep:
        # request step
        step_info += ".extract()"
        for extract_name, extract_path in teststep["extract"].items():
            if extract_path.startswith("$.."):
                step_info += f""".with_jsonpath('{extract_path}', '{extract_name}')"""
            else:
                step_info += f""".with_jmespath('{extract_path}', '{extract_name}')"""

    if "export" in teststep:
        # reference testcase step
        export: List[Text] = teststep["export"]
        step_info += f".export(*{export})"

    if "validate" in teststep:
        step_info += ".validate()"

        for v in teststep["validate"]:
            validator = uniform_validator(v)
            assert_method = validator["assert"]
            check = validator["check"]
            if '"' in check:
                # e.g. body."user-agent" => 'body."user-agent"'
                check = f"'{check}'"
            else:
                check = f'"{check}"'
            expect = validator["expect"]
            if isinstance(expect, Text):
                expect = f'"{expect}"'

            message = validator["message"]
            if message:
                step_info += f".assert_{assert_method}({check}, {expect}, '{message}')"
            else:
                step_info += f".assert_{assert_method}({check}, {expect})"

    return f"Step({step_info})"


def make_testcase_main_chain_style(testcase: Dict) -> Text:
    config = testcase["config"]
    testcase_cls_name = config['name']
    return f"TestCase{testcase_cls_name}"


def make_module_conftest(testsuite_abs_path, setup_class_list, teardown_class_list):
    # 导入 setup、teardown 模块
    imports_list = []
    for tc_cls_name in setup_class_list + teardown_class_list:
        imports_list.append(pytest_model_import_cache_mapping[tc_cls_name])

    if not imports_list:
        return
    temp_path = convert_relative_project_root_dir(testsuite_abs_path)
    # current file compared to ProjectRootDir
    diff_levels = len(temp_path.split(os.sep))

    data = {
        "diff_levels": diff_levels,
        "imports_list": imports_list,
        "setup_class_list": setup_class_list,
        "teardown_class_list": teardown_class_list,
    }
    content = __MODULE_CONFTEST_TEMPLATE__.render(data)
    # formatted_content, _ = FormatCode(content, style_config='google')

    module_conftest_python_abs_path = os.path.join(testsuite_abs_path, 'conftest.py')

    # ensure new file's directory exists
    dir_path = os.path.dirname(module_conftest_python_abs_path)
    if not os.path.exists(dir_path):
        os.makedirs(dir_path)

    with open(module_conftest_python_abs_path, "w", encoding="utf-8") as f:
        f.write(content)


def make_testcase(testcase: Dict) -> Text:
    """convert valid testcase dict to pytest file path"""
    # ensure compatibility with testcase format v2
    # testcase = ensure_testcase_v3(testcase)

    # validate testcase format
    load_testcase(testcase)

    case_id = testcase["id"]
    test_type = testcase["test_type"]
    config = testcase["config"]
    setups = testcase["setups"]
    teardowns = testcase["teardowns"]
    testcase_tags = testcase["tags"]
    if test_type:
        testcase_tags.append(test_type)
    project = config["project_name"]
    module = config["module_name"]
    suite = config["suite_name"]
    testcase_name = testcase['case_name']
    testcase_cls_name = testcase['case_safe_name']
    testcase_description = testcase['description']
    # 生成pytest用例文件，每个case对应一个文件，其内包含一个Class，多个Step(用例步骤)
    logger.info("start to make testcase: {}".format(testcase_cls_name))

    testcase_abs_path = __ensure_absolute(testcase["config"]["path"])
    testcase_python_abs_path, _ = convert_testcase_path(testcase_abs_path)

    global pytest_files_made_cache_mapping
    if testcase_python_abs_path in pytest_files_made_cache_mapping:
        if "TestCase" + testcase_cls_name in pytest_files_made_cache_mapping[testcase_python_abs_path]:
            logger.info("skip make testcase: {}, already exist!".format(testcase_cls_name))
            # return testcase_python_abs_path
            pass

    config["variables"] = convert_variables(config.get("variables", {}), testcase_abs_path)

    # 引用用例
    imports_list = []
    teststeps = testcase["teststeps"]
    for teststep in teststeps:
        if not teststep.get("testcase"):
            continue

        # make ref testcase pytest file
        test_content = teststep["testcase"]
        if not isinstance(test_content, Dict):
            raise exceptions.TestCaseFormatError(f"Invalid teststep: {teststep}")

        # api in v2 format, convert to v3 testcase
        if "request" in test_content and "name" in test_content:
            test_content = ensure_testcase_v3_api(test_content)

        test_content.setdefault("config", {})["path"] = testcase_abs_path
        ref_testcase_python_abs_path = make_testcase(test_content)

        # override testcase export
        ref_testcase_export: List = test_content["config"].get("export", [])
        if ref_testcase_export:
            step_export: List = teststep.setdefault("export", [])
            step_export.extend(ref_testcase_export)
            teststep["export"] = list(set(step_export))

        # prepare ref testcase class name
        ref_testcase_cls_name = pytest_files_made_cache_mapping[
            ref_testcase_python_abs_path
        ]
        teststep["testcase"] = ref_testcase_cls_name

        # prepare import ref testcase
        ref_testcase_python_relative_path = convert_relative_project_root_dir(
            ref_testcase_python_abs_path
        )
        ref_module_name, _ = os.path.splitext(ref_testcase_python_relative_path)
        ref_module_name = ref_module_name.replace(os.sep, ".")
        import_expr = f"from {ref_module_name} import TestCase{ref_testcase_cls_name} as {ref_testcase_cls_name}"
        if import_expr not in imports_list:
            imports_list.append(import_expr)

    testcase_path_1 = convert_relative_project_root_dir(testcase_abs_path)
    # current file compared to ProjectRootDir
    diff_levels = len(testcase_path_1.split(os.sep))

    # 导入 setup、teardown 模块
    for tc_cls_name in setups + teardowns:
        imports_list.append(pytest_model_import_cache_mapping[tc_cls_name])

    data = {
        "version": __version__,
        "testcase_path": testcase_path_1,
        "diff_levels": diff_levels,
        "epic": project,
        "story": module or suite,
        "suite": suite,
        "case_id": case_id,
        "case_link": 'http://xxxx-{}.html'.format(case_id),
        "case_name": testcase_name,
        "case_desc": testcase_description,
        "case_tags": testcase_tags,
        "class_name": testcase_cls_name,
        "test_type": test_type,
        "imports_list": imports_list,
        "config_chain_style": make_config_chain_style(config),
        "parameters": config.get("parameters"),
        "teststeps_chain_style": [
            make_teststep_chain_style(step) for step in teststeps
        ],
        "setups": setups,
        "teardowns": teardowns,
    }
    content = __TEMPLATE__.render(data)
    # formatted_content, _ = FormatCode(content, style_config='google')

    # ensure new file's directory exists
    dir_path = os.path.dirname(testcase_python_abs_path)
    if not os.path.exists(dir_path):
        os.makedirs(dir_path)

    with open(testcase_python_abs_path, "w", encoding="utf-8") as f:
        f.write(content)

    pytest_files_made_cache_mapping[testcase_python_abs_path] = testcase_cls_name
    __ensure_testcase_module(testcase_python_abs_path)

    logger.info(f"generated testcase: {testcase_python_abs_path}")

    if test_type not in ['setup', 'teardown']:
        # 不单独执行setup、teardown
        pytest_files_run_set.add(testcase_python_abs_path)

    return testcase_python_abs_path


def make_testsuite(testsuite: Dict, dir_path: Text = None, idx: int = None) -> NoReturn:
    """convert valid testsuite dict to pytest folder with testcases"""
    # validate testsuite format
    load_testsuite(testsuite)

    testsuite_config = testsuite["config"]
    suite_safe_name = testsuite.get('suite_name', '')
    testsuite_dir_name = "test_{}".format(suite_safe_name) if suite_safe_name else "test_suite_{}".format(
        str(idx + 1).zfill(3))
    testsuite_path = os.path.join(dir_path, testsuite_dir_name)
    testsuite_path = ensure_file_abs_path_valid(testsuite_path)
    testsuite_config["path"] = testsuite_path
    testsuite_variables = convert_variables(testsuite_config.get("variables", {}), testsuite_path)
    logger.info(f"start to make testsuite: {testsuite_path}")

    def make_testcase_ref(testcase_ref):
        # get referenced testcase content
        testcase_dict = testcase_ref  # ['testcase']
        testcase_dict.setdefault("config", {})
        test_type = testcase_dict.get("test_type")
        if test_type in ['setup', 'teardown']:
            tc_py_name = "test_{}_{}.py".format(test_type, testcase_ref["case_safe_name"])
        else:
            tc_py_name = "test_{}.py".format(testcase_ref["case_safe_name"])
        testcase_dict["config"]["path"] = os.path.join(testsuite_path, tc_py_name)

        # override base_url
        base_url = testsuite_config.get("base_url") or testcase_ref.get("base_url")
        if base_url:
            testcase_dict["config"]["base_url"] = base_url
        # override verify
        if "verify" in testsuite_config:
            testcase_dict["config"]["verify"] = testsuite_config["verify"]
        # override variables
        # testsuite testcase variables > testsuite config variables
        testcase_variables = convert_variables(testcase_ref.get("variables", {}), testsuite_path)
        testcase_variables = merge_variables(testcase_variables, testsuite_variables)
        # testsuite testcase variables > testcase config variables
        testcase_dict["config"]["variables"] = convert_variables(
            testcase_dict["config"].get("variables", {}), testsuite_path
        )
        testcase_dict["config"]["variables"].update(testcase_variables)

        # make testcase
        tc_py_abs_path = make_testcase(testcase_dict)

        # 生成setup / teardown 类导入表达式
        if test_type in ['setup', 'teardown']:
            global pytest_model_import_cache_mapping

            # prepare ref testcase class name
            ref_testcase_cls_name = pytest_files_made_cache_mapping[tc_py_abs_path]

            # prepare import ref testcase
            ref_testcase_python_relative_path = convert_relative_project_root_dir(tc_py_abs_path)
            ref_module_name, _ = os.path.splitext(ref_testcase_python_relative_path)
            ref_module_name = ref_module_name.replace(os.sep, ".")
            import_expr = f"from {ref_module_name} import TestCase{ref_testcase_cls_name} as {ref_testcase_cls_name}"
            pytest_model_import_cache_mapping[ref_testcase_cls_name] = import_expr

    # 创建 setup case
    for setup_tc_ref in testsuite["setup_tcs"]:
        make_testcase_ref(setup_tc_ref)
    # 创建 teardown case
    for teardown_tc_ref in testsuite["teardown_tcs"]:
        make_testcase_ref(teardown_tc_ref)

    # 创建 setup_class case
    setup_class_list = []
    for setup_class_tc_ref in testsuite["setup_class_tcs"]:
        make_testcase_ref(setup_class_tc_ref)
        setup_class_list.append(setup_class_tc_ref["testcase"]["config"]["name"])
    # 创建 teardown_class case
    teardown_class_list = []
    for teardown_class_tc_ref in testsuite["teardown_class_tcs"]:
        make_testcase_ref(teardown_class_tc_ref)
        teardown_class_list.append(teardown_class_tc_ref["testcase"]["config"]["name"])

    # 创建 CASE
    for tc_ref in testsuite["testcases"]:
        make_testcase_ref(tc_ref)

    # 创建module conftest.py
    # testsuite_abs_path = __ensure_absolute(testsuite_path)
    make_module_conftest(testsuite_path, setup_class_list, teardown_class_list)


def __make(test_data: List[Dict], testcase_path: Text) -> NoReturn:
    """convert valid test_data dict to pytest folder with testsuites"""
    logger.info("\n" + "=" * 66 + " make py files starts " + "=" * 66)
    global pytest_files_run_set
    pytest_files_run_set = set()
    for idx, test_suite in enumerate(test_data):
        make_testsuite(test_suite, testcase_path, idx)


def main_make(test_data: List[Dict], testcase_path: Text) -> List[Text]:
    if not test_data:
        logger.warning("测试设计数据为空！")
        return []
    try:
        __make(test_data, testcase_path)
    except exceptions.MyBaseError as ex:
        logger.error(ex)
        # sys.exit(1)
        raise Exception(ex)

    # format pytest files
    pytest_files_format_list = pytest_files_made_cache_mapping.keys()
    format_pytest_with_black(*pytest_files_format_list)

    # compile pytest files
    # compile_pytest(*pytest_files_run_set)

    return list(pytest_files_run_set)


def init_make_parser(subparsers):
    """ make testcases: parse command line options and run commands.
    """
    parser = subparsers.add_parser(
        "make", help="Convert YAML/JSON testcases to pytest cases.",
    )
    parser.add_argument(
        "testcase_path", nargs="*", help="Specify YAML/JSON testcase file/folder path"
    )

    return parser


if __name__ == '__main__':
    pass
